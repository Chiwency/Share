#									InnoDB 的索引策略

## 一、InnoDB的数据页结构

​	之前我们在讲 InnoDB 的内存结构的时候讲过，页(Page)是InnoDB管理储存结构的基本单位，默认的大小是16KB. 页有很多种类型，有存放日志信息的页，存放表空间信息的页等。我们今天主要讲的是**数据页**，也叫**索引页**，看名字可以知道，就是专门存放数据（record）的页。

> InnoDB 中有个概念叫***索引即数据，数据即索引***  ,也就是数据本身也构成索引
>
> MyISAM 就是索引和数据分离，数据是数据，索引是索引



### 数据页结构

![img](https://user-gold-cdn.xitu.io/2019/12/17/16f13ee1e2dfac7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 为了节省时间，本章挑和索引有关的重点讲
>
> 想具体了解可以看MySQL的内部文档 https://dev.mysql.com/doc/internals/en/innodb-fil-header.html



|          名称          |        中文        |                     描述                     |
| :--------------------: | :----------------: | :------------------------------------------: |
|      File Header       |      文件头部      |        页的一些通用信息，比如页的类型        |
|      Page Header       |      页面头部      |             数据页专有的一些信息             |
| ***Infimum+Supermum*** | 最小记录和最大记录 |          两个虚拟的行记录，后面会讲          |
|   ***User Records***   |      用户记录      |                真正储存的数据                |
|       Free Space       |      空闲空间      |            页面中没有被使用的空间            |
|  ***Page Directory***  |       页目录       | 相当于书的目录，对页内储存的数据分类做的目录 |
|      File Trailer      |      文件尾部      |                校验页是否完整                |



我们先建一张表

```sql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
```

> 注意这个 Row_FORMAT=Compact    我们储存的记录也有几种不同的格式，Compact是紧凑类型，比较省空间，此外还有 Dynamic，Redundant，Compressed这几种类型，区别不是很大。
>
> MySQL 8.0 默认是 Dynamic格式，支持变长字段，比如VARCHAR(10)
>
> 因为图用的是别人的，所以以 Compact格式讲，问题不大
>
> 其实不同的记录格式在索引树的实现上的储存也有一些区别，但是本章就不细究了。
>
> 具体参考：https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html



注意我们把 C1 设置成了主键，下面是 Compact格式的记录结构



![image_1c9o2eib2vl11qnf1dfl1d2lco313.png-76.4kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c0feca77be3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



|     名称     | 大小（bit） |                             描述                             |
| :----------: | :---------: | :----------------------------------------------------------: |
| delete_mask  |      1      |            用来标记这条记录是否被删除，就像软删除            |
| min_rec_mask |      1      |   B+树的每层非叶子节点中的最小记录都会添加该标记，后面解释   |
|   n_owned    |      4      |             表示当前记录组拥有的记录数，后面解释             |
|   heap_no    |     13      |                表示当前记录在记录堆的位置信息                |
| record_type  |      3      | 表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录 |
| next_record  |     16      |            表示下一条记录的相对位置，是一个偏移量            |

![](https://user-gold-cdn.xitu.io/2019/5/8/16a95c0ff1ae5364?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



下面给表插入一些信息

``` sql
 mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'),
 	 ->	(2, 200, 'bbbb'), 
 	 ->	(3, 300, 'cccc'),
 	 ->	(4, 400, 'dddd');
```

![image_1c9qs0j281knc16hc1hqsgj01v0o2c.png-82.8kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c0ff83f9870?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



+ heap_no

  这个属性表示当前记录在本页的位置 2,3,4,5这样排序下来。 发现是不是少了0和1。 前面讲过我们每个页里面有两条虚拟记录***Infimum+Supermum***，分别表示最小记录和最大记录。所以我们规定了，最小记录是0，最大记录是1。

  所以你可以发现，记录是能比较大小的，除了这两条规定的最小和最大记录，我们插入的记录是根据主键值比较大小的。如果不是数字，每个编码的字符集都有一种或几种排序规则（collation），就是用来比较大小的

  这两条虚拟记录就相当于规定了一个闭区间，再往中间填数就行。除了下面会讲的用途，在对记录加gap锁的时候也很有用。 

+ next_record

  它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。是不是感觉像一个单向链表。

  需要注意的是，我们记录不是按照插入顺序排序的，而是按照主键值由小到大排序的。

  

  ![image_1cot1r96210ph1jng1td41ouj85c13.png-120.5kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c1084c440b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如果我们删掉一条记录，就会变成这样

![image_1cul8slbp1om0p31b3u1be11gco9.png-119.6kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c108ee1da43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

需要注意的是，被删除的记录不会马上被删除，会被归类到页面中的垃圾链表中，当下次插入的记录的大小和这条记录相同时，就可以重用这部分空间。



### Page Directory (页目录)

​	

​	我们知道数据页中的记录是按照主键大小顺序串联成了一个单向链表，如果我们想按照主键查询某条记录呢？

```mysql
SELECT * FROM page_demo WHERE c1 = 3;
```

> 记得c1列是主键

我们可以很自然的想到，从链表的头部（即最小记录Infimum）开始遍历链表来查找。在记录小的情况下没问题，但是在记录量大的情况下，遍历显然是不可能的，过于暴力。 所以我们要寻找一种高效的查询策略。

Page Directory 就是用来提高查询效率的。目录目录，我们会想到书的目录，把相似的内容分成一节一章然后组成书的目录。 同样的，页目录就是把记录分成好几组来组成一个目录。



![image_1couate3jr19gc18gl1cva1fcg34.png-100.8kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c10f2e61ad5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

+ 我们把每组记录的最后一条记录的地址偏移量放进页目录的一个槽中。并且给该记录填充n_owned 属性，就是表示该组记录有多少条。 （槽就相当于一本书的章节，章节里面分了好多小节）
+ 对于最小记录所在的分组只能有 ***1*** 条记录，最大记录所在的分组拥有的记录条数只能在 ***1~8*** 条之间，剩下的分组中记录的条数范围只能在是 ***4~8*** 条之间
+ 插入的情况就自行脑补吧【doge】



假设我们又新插入了一些记录

![image_1couate3jr19gc18gl1cva1fcg34.png-100.8kB](https://user-gold-cdn.xitu.io/2019/5/8/16a95c10e3449897?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

+ 假如我们要查询主键值为2的那条记录， 先算出中间位置的槽，然后比较槽对应那条记录的主键值，是槽2，对应主键值是 8 ，2<8，所以在上半部分，上半部分中间槽是槽1，主键值是4，2<4，诶，又在上半部分，是槽0，槽0只存放最小记录，所以可以确定，该记录在槽1对应的那组记录中。所以取槽0的地址偏移量，往下遍历即可
+ 这种算法是不是似曾相识？？  这就是二分查找！ 



### Page Header、File Header 

	这两个结构储存了页面的一些信息，具体不讲了，但是记得要有，后面我们讲索引，其中关于页的一些属性都储存在这，后面就不再赘述





## B+树索引

### 聚簇索引(主键索引)

我们前面讲过利用Page Directory 来定位一张数据页中的记录。但是当数据量特别大的时候，就需要大量的数据页来储存数据，那么我们怎么根据主键定位一条记录呢？	具体可以分为两步

+ 定位记录所在的数据页
+ 定位数据页中的记录

所以我们现在要解决的是怎么定位记录所在的数据页



咦，是不是和之前讨论的如何在数据页中定位记录有些许的相似？  假设我们把一张张数据页看成是Page Directory 中一个槽对应的一组记录，我们也可以把这些数据页所有记录都按照主键大小排序，并且设置一个目录来分组管理这些数据页。 是不是发现可以套娃？？？！！！ 



![1](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd282d6b9b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



+ 和记录不同的是，数据页之间是用双向链表链接起来的， 但都是按照主键值由小到大排序
+ 图中目录项记录储存了每张页面的最小的主键值和页编号，通过页编号可以定位一张页面。 是不是发现和数据页中的槽很像？
+ 目录项实际上也是一条记录，也有通用的记录格式，与普通记录不同的是，目录项记录的record_type为1，表示B+树非叶节点记录,它不储存我们实际的用户数据，而是只作为索引。 普通记录的record_type则为0
+ 因为目录项记录也是记录，所以我们可以把它放在数据页中 



![2](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd295fd42b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



当数据量更大的情况呢，页30不能再储存更多的目录项记录，这时候就需要更多的目录页	



![3](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd29ebc7a4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



哈！ 那么问题来了，我们怎么定位那些目录页呢？？    答案是，再持续套娃！！ 我们给这些目录页也建一层目录页



![4](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a6c7a65f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我们把它抽象出来看

![5](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a6fb9126?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



呐，这就是B+树了。 底层的叫叶节点，其他叫非叶子节点。 一般B+树长这样

![6](https://images2015.cnblogs.com/blog/569090/201703/569090-20170328142941623-2145260028.png)



​	

为了储存更多的数据，我们可以无限套娃，加高B+树，但是每增加一层B+树，每次查找记录的时候就会多一次磁盘IO,很影响性能的，所以mysql设计的B+树的高度一般在3层左右。3层一般可以存千万数量级的记录



+ 现在可以说，***一棵B+树就是一个索引***，上面那条B+树的叶子节点记录的是完整用户记录，所以这样的索引我们叫主键索引

  > 现在能体会InnoDB中 数据即索引，索引即数据的理念吧

+ 所以我们不需要显示地创建聚簇索引，我们只要指定了主键（如果没有指定主键，但是指定了有unique属性的列，就把该列作为主键，如果都没有，InnoDB会隐式的创建列名为row_id的列作为主键），就会自动创建聚簇索引。         

  但是最好我们显示定义主键

  如果我们自己定义了主键，我们以后查询就可以用主键作为条件查询了，贼快

  比如 c1是主键 

  ```mysql
  SELECT * FROM page_demo WHERE c1 = 3;
  ```

  但是c2不是主键，我们也没有为它建立索引

  ```mysql
  SELECT * FROM page_demo WHERE c2 = 3;
  ```

  那我们只能去上面那颗B+树的叶子节点开始从头遍历了，你说得有多慢，，，，

+ 所以现在是不是能理解为啥主键只能有一个了

  > 因为我们的数据就是索引，完整数据就组成一棵B+树，我们不可能为了再建一个主键索引又去把所有记录复制一遍再建一棵B+树吧。 那是对空间的极大浪费



### Secondary Index (辅助索引，二级索引)

​	前面我们解决了当搜索条件是主键值的情况,可以通过聚簇索引快速查找记录。 但是，but，如果我们的搜索条件不是主键值呢？	

为了防止忘记，再把建表语句贴出来.

```mysql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)    
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
```

现在根据c2列进行查询

```sql
SELECT * FROM page_demo WHERE c2 = 3;
```

c2不是主键，所以我们无法通过聚簇索引快速找到这条记录。 我们只能在B+树的叶子节点开始遍历所有记录，找到为止。

但是，如果我们要经常对 c2 列进行查询，同时表的数据很多，那这么遍历是极其慢的。 所以我们要***对c2列建立索引***，加快查询速度



我们可以很自然的想到，用对主键建立索引类似的策略对c2列建立索引， 所以，就是再建立一棵B+树。

前面我们提到，聚簇索引的B+树的叶子节点储存了完整的用户数据（把所有的列值都储存了进来），那我们再建一棵B+树对c2进行索引的话，我们DUCK不必再去储存所有的用户数据了，这样会造成大量的冗余。我们可以只储存c2列的列值，因为是要对c2列进行索引嘛。



**在InnoDB中，一个索引就对应一棵B+树，其中只有聚簇索引对应的B+树储存了完整的用户数据，每个表只有一个聚簇索引，其他索引都叫二级索引或者辅助索引**    

> 至于为什么叫二级索引，我们后面就会知道了



现在还有一个问题需要解决

+ 为了避免数据的冗余，我们再建B+树时不再把完整的用户数据储存在B+树中，比如我们只储存c2列的值
+ 但是如果我们进行如下查询

```mysql
SELECT * FROM page_demo WHERE c2 = 3;
```

+ 当我们需要获取所有列的信息（完整数据）怎么办，光在二级索引处定位到 c2=3 可不行，二级索引没有储存完整的数据。只有聚簇索引处才储存了完整数据。 所以我们又需要回到聚簇索引去查询完整信息。 

  还记得聚簇索引是根据什么查询的？ 是主键！ 所以我们在二级索引处额外再添一个主键列， 就是储存  c2+ c1的组合。    

  就相当于我们把完整记录的位置给储存了下来。



![7](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a89adfa5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我们看图需要注意以下几点

+ 每条目录项记录由 **c2 + 页号** 组成， 每条叶子节点记录由 **c2 + c1(主键)** 组成
+ 页内记录根据 c2 列 的大小排序

```mysql
SELECT * FROM page_demo WHERE c2 = 3;
```

查询过程如下：

+ 访问二级索引的B+树，定位到 **c2=3** 的那条记录，在页34那里
+ 得知该记录的主键值为 5（c1=5）
+ 根据 c1=5 去访问聚簇索引的B+树，定位到那条完整的记录 ，  这个过程也叫***回表***

所以如果我们想根据 c2 的值获取完整的记录的话还需要到聚簇索引中再查一遍，这个过程也叫 **回表**(重要的话说两遍)

但是如果我们只查询c2,c1列的值

```mysql
SELECT c2，c1   FROM page_demo WHERE c2 = 3;
```

因为二级索引中已经储存了 c2和c1列的值，所以我们第一次定位到记录后直接拿出来放进结果集即可，不需要再进行一次回表操作了

这种情况也叫**覆盖索引查询** 

所以我们查询时不要查询无用的列，尽量使用覆盖索引查询，可以减少回表产生的IO开销。

> 因为一般要进行回表操作，所以就把它叫做二级索引



**因为每个索引对应一棵B+树，而平时对数据的增删改操作同时也会去修改对应的B+树，如果索引建的太多，会导致数据的增删改操作奇慢。 所以对于经常要修改的列，一般不要建索引，对不常查询的列，也不要建索引。对重复率太高的列（比如男，女），也不要建索引（会导致大量的回表操作），还不如遍历来的快。**

数据量太少也别建索引了，还不如遍历来的快，，，，



## 联合索引

我们也可以同时为多个列建立索引

```mysql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    ->	   key(c2,c3)                 -- 注意这条，顺序很重要
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
```

+ 为c2,c3列建立联合索引，就是按照c2,c3的值来为记录排序
+ 因为c2在前， 所以先比较c2的值来排序，如果c2的值相同，再比较c3的值

```
我们能通过索引快速查找记录的基础是什么？？ 就是数据是有序的，有序才能快速查找
所以我们对列建立索引就是要对 被索引的列 进行排序。
```



> 如果c2 ,c3 的值都相同怎么办？  其实前面二级索引时也会有这样的情况。 为了保证数据的唯一性，对于允许有重复值的列，会在目录项记录里也额外添加主键值，因为主键值一定是唯一的。  所以当c2,c3都相等的话，会再比较主键值      ***前面在目录项记录中只画了 c2+页号    实际应该是 c2+c1+页号***



![8](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2b0b70d72?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

注意这几种情况

```mysql
SELECT * FROM page_demo WHERE c2 = 3;  --可以使用联合索引
```

```mysql
SELECT * FROM page_demo WHERE c3 = 'e';  --不能使用联合索引
```

```mysql
SELECT * FROM page_demo WHERE c2 = 3 AND c3='e'  --可以使用联合索引
SELECT * FROM page_demo WHERE c3 = 'e' AND c3=3  --也可以使用联合索引，优化器会自己重组成上面那句
```

**至于为啥，仔细看上图**

我们建表时是 key(c2,c3)  

c2,排在前面（最左边）

所以这个也叫***最左前缀匹配原则***



所以！所以！所以！ **千万不要以为联合索引就意味着你可以肆无忌惮的使用被索引列进行查询！！！** 

**定要遵循最左前缀匹配原则，不要忽略顺序**



> 最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。







图片全部来自掘金小册，小册是付费的，所以这篇文章不放在网上

MySQL 是怎样运行的：从根儿上理解 MySQL

https://juejin.im/book/6844733769996304392

有时间可以看看小册，小册讲的贼好，还全面


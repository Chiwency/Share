

## 异常控制

异常控制就是正常的工作流被打断了，要么直接退出，要么先去做其他的事情，做完了再回头继续干。



每种类型异常都有一个专门的异常号。一部分是处理器设计者分配的，有`零除、缺页、内存访问越界、断点及算术溢出`  其他号码是操作系统内核设计者分配的，有`系统调用、外部I/O设备信号`

异常号相当于索引，通过异常号在异常表中查找对应的异常处理程序的地址进行调用。

异常处理程序运行在内核模式下。

>操作系统为了提供一个进程的抽象，限制了每个进程可以执行的指令和访问的地址空间，这样的进程就叫运行在用户模式下，而内核模式就不受限制。异常处理程序运行在内核模式之下，所以有些进程为了执行一些需要额外权限的系统调用，就要故意引发中断陷入内核态。



### 异常的种类

| 类别 | 原因                 | 返回位置                         |
| ---- | -------------------- | -------------------------------- |
| 中断 | 来自I/O设备的信号    | 下一条指令                       |
| 陷阱 | 有意的异常(系统调用) | 下一条指令                       |
| 故障 | 潜在的可恢复的错误   | 可能返回到当前指令(如果恢复的话) |
| 终止 | 不可恢复的错误       | 不返回                           |



+ 中断： 中断是异步发生的，就不是由某条具体的指令引发的中断，是由处理器外部I/O设备的信号引发的中断。处理器执行完中断处理程序后，就继续执行之前被打断的下一条指令。

+ 陷阱： 就是故意引发的异常，同步的，就是执行某条指令的结果。前面讲的系统调用要陷入内核态，就是通过引发陷阱异常实现的。

+ 故障：就是可以被修复的错误。如缺页异常，修复后继续执行被中断的指令。

  >  一般保护故障：通常是因为一个进程引用了一个未定义的虚拟内存区域(指针引用错误)，或者是该进程尝试写一个只读文本，Linux不会去恢复这个故障，一般直接报错"段故障(Segmentation fault)"

+ 终止：就是不能被修复的错误，一般是硬件错误，被打断后调用abort(***很熟悉了***)例程来终止该进程。



### 系统调用

  读写文件或者创建一个新进程都需要系统调用函数。可能是因为区分用户态和内核态是为了提供对进程的抽象，而文件不独属于某个进程，所以由内核管理。



### 上下文切换

  上下文(context)就是内核重新启动一个被抢占的进程所需要的状态，各种寄存器的值，用户栈之类的。进程间的交互执行需要进行上下文切换（比如要保存当前寄存器的值，切换回来的时候又要放入寄存器）。这是并发程序的一大开销，之前说过，运行一个简单的不会被阻塞的程序就不要用并发，因为上下文切换的开销更大。

  系统调用有可能会发生上下文切换，比如read操作是阻塞的，这时候内核就会把控制权让渡给其他进程，发生上下文切换。

  中断也可能发生上下文切换，比如进程运行了足够长时间会触发定时器中断，内核就会把控制权让渡给其他进程。

> 需要注意的是，上下文切换是需要内核态支持的，所以说上下文切换的实现应该就是靠上面两种异常。

下面看图，进程A被read函数阻塞后触发陷阱异常(系统调用)，陷入内核，然后保存自己的上下文状态(前面提到过进程从用户模式转移到内核模式时，需要把部分上下文压入内核栈中，而不是用户栈，所以这需要内核态的支持)

A进程随后进入运行队列等待，B进程开始以内核态执行（应该是读取上下文），随后B进程进入用户模式执行任务。这样就完成了一次上下文切换。

之前看面经有考到过用户模式和内核模式，***注意这是要考的，，，，***

![image-20210408223747830](/Users/mac/Library/Application Support/typora-user-images/image-20210408223747830.png)





### 进程相关

进程的三种状态：

+ 运行： 要么正在被执行，要么等待被执行。
+ 停止： 就是挂起(suspended)，不会被调度，直到收到信号才会被唤醒或者终止。
+ 终止： 应该就是直接挂了（等待被父进程回收）。

**僵尸进程**  ***要考的，，，***

> 一个终止了但是还没被回收的进程称为僵尸进程(zombie)，一般是等待父进程回收，如果父进程也挂了，那就由 init进程去回收它。 ps可以查看进程的状态, Linux里ps可以看到五种状态，也要考的，，，

并发编程时要考虑及时回收僵尸进程，父进程用各种wait函数等待子进程的结束然后回收它们，而不要全部丢给init去管。



### execve和fork

这个需要注意的是 `execve`执行的时候直接覆盖当前进程的所有内容，原地执行`execve`要执行的指令(相当于把父进程直接变成了另一个进程)。

网上一个很形象的比喻是，`execve` 是变身，而`fork` 是分身

所以为了避免调用 `execve` 的父进程被覆盖，父进程应该先`fork`一个子进程，然后在子进程中调用`execve`

有一个小`demo`



### 信号

> 又是要考的，，，，

~~***又不知道要怎么讲***~~   

+ 发送信号： 是通过内核更新目的进程上下文中的某个状态，来发送一个信号给目的进程。进程间也可以靠信号来通信，但是也要经过内核中转。比如`kill -9` 就是`kill`进程显示地要求内核把信号`9`发送给目的进程。

+  接受信号： 内核强迫目的进程对其发出的信号做出反应时，目的进程就接受了信号。一般是当进程从内核模式切换回用户模式时(就是处理完异常准备返回执行下一条指令的时候)，回检查一下待处理的信号集合，如果为空，就继续执行下一条指令，不为空就随机选一个响应。目的进程可以忽略，终止，或者执行信号处理程序来捕获这个信号（比如内存访问越界，内核给进程发送`SIGSEGV`信号，进程捕获到该信号后终止并向用户报告）。
+ 阻塞信号： 一个发出了但是没有被进程接收的信号叫做待处理信号。一种类型至多只能有一个待处理信号，再发相同类型的信号的话就会被丢弃。进程可以选择性阻塞某种类型的信号，阻塞只是不接收该信号，但是不影响该信号的发送。



***下面是要考的***

![image-20210409183440199](/Users/mac/Library/Application Support/typora-user-images/image-20210409183440199.png)





> 每条命令后面加 `&` ，把进程丢到后台运行 
>
>  fg %[number]   把后台作业丢到前台运行
>
> 前台可以看到输入嘛，后台看不到 而且前台不会被阻塞
>
> 所以一般压缩解压之类的要打印进度的命令，或者启动一个有GUI的应用(在前台就会阻塞shell)，这些都丢到后台运行就好
>
> History | grep 'ls'  这种通过管道连接的两个命令在前台跑，就是创建了两个子进程，由前台进程管理

Linux下，按`ctrl+c` 键，就是由内核发送一个`SIGINT`信号 (相当于`kill- 9`)给前台进程组中的每个进程，终止前台作业。注意是终止前台进程组，不是前台这个单独的进程。 之前在面经上看到有考。

`ctrl+z`键就是挂起前台进程组所有进程。  可以用`bg %jobnumber`命令唤醒

`kill` `alarm` 都是发送信号给某些进程的程序，就不细讲了





后面的就很玄学了，如何防止并发程序被信号干扰而产生不可预料的错误。。。。就不总结了，玄学的很，，，，

